<html><head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Random tech blog">
<meta name="author" content="Matthew Morrison">
<title>Matthew Morrison's blog</title>
<link href="/public/styles/global.css" rel="stylesheet">
<link href="/public/styles/snake.css" rel="stylesheet"></head>
<body class="bg-dark text-white"><main class="m-auto mt-16 flex max-w-fit flex-col items-start gap-4 px-4"><div class="heading flex w-full justify-between"><h1>Score: 
<span id="score">0</span></h1>
<h1>High score: 
<span id="high-score">0</span></h1></div>
<div class="flex" id="root"></div>
<div class="heading flex w-full justify-between"><h1 id="title"></h1>
<button class="play-button cursor-pointer rounded-2xl bg-blue-500 hover:bg-blue-600" id="play-button">Play</button></div></main></body>
<script>function getSnakeSpeed(state) {
    return Math.max(300 - Math.log(state.score + 1) * 60, 100);
  }
  function assert(condition, msg) {
    if (!condition)
      throw new Error(msg);
  }
  function assertSnakeNode(node, msg) {
    assert(node.type === "snake", msg);
  }
  function getHighScore() {
    const highScore = window.sessionStorage.getItem("high-score");
    if (highScore == null)
      return 0;
    return parseInt(highScore);
  }
  function setHighScore(score) {
    window.sessionStorage.setItem("high-score", score.toString());
    const element = document.getElementById("high-score");
    assert(element, "Cannot find high score dom node");
    element.innerHTML = score.toString();
  }
  function createRandomPoint() {
    return {
      col: Math.floor(Math.random() * 13),
      row: Math.floor(Math.random() * 13)
    };
  }
  function getNode(grid, point) {
    return grid[point.col]?.[point.row];
  }
  function initGrid(root) {
    return Array.from({ length: 13 }, (_, i) => {
      const col = document.createElement("div");
      root.appendChild(col);
      return Array.from({ length: 13 }, (_, j) => {
        const row = document.createElement("div");
        col.appendChild(row);
        row.classList.add("custom-border");
        row.classList.add("node");
        return row;
      });
    });
  }
  function initGridState(grid) {
    return grid.map((col) => col.map((row) => ({
      type: "empty",
      element: row
    })));
  }
  function createFoodPoint(grid) {
    const point = createRandomPoint(), node = getNode(grid, point);
    assert(node, "Unable to find point in createFoodPoint");
    return node.type !== "empty" ? createFoodPoint(grid) : point;
  }
  function createKeyDownHandler(state) {
    return async (event) => {
      switch (event.key) {
        case "ArrowUp":
          if (state.direction === "down")
            return;
          state.pendingDirection = "up";
          break;
        case "ArrowDown":
          if (state.direction === "up")
            return;
          state.pendingDirection = "down";
          break;
        case "ArrowLeft":
          if (state.direction === "right")
            return;
          state.pendingDirection = "left";
          break;
        case "ArrowRight":
          if (state.direction === "left")
            return;
          state.pendingDirection = "right";
          break;
        case "p":
          state.pause = !state.pause;
          break;
      }
      const headNode = getNode(state.grid, state.head);
      assert(headNode, "Cannot find head node");
      assertSnakeNode(headNode);
      headNode.direction = state.direction;
    };
  }
  function initGameState(grid) {
    setHighScore(getHighScore());
    const gridState = initGridState(grid), head = {
      col: Math.floor(6.5),
      row: Math.floor(6.5)
    }, direction = "up", headNode = getNode(gridState, head);
    assert(headNode, "Cannot find head node");
    headNode.type = "snake";
    assertSnakeNode(headNode);
    headNode.direction = direction;
    const food = createFoodPoint(gridState), foodNode = getNode(gridState, food);
    assert(foodNode, "Cannot find food node");
    foodNode.type = "food";
    const state = {
      direction,
      pendingDirection: direction,
      grid: gridState,
      score: 0,
      pause: !1,
      controller: new AbortController,
      food,
      head,
      tail: structuredClone(head),
      gameOver: !1,
      title: ""
    };
    document.addEventListener("keydown", createKeyDownHandler(state), {
      signal: state.controller.signal
    });
    return state;
  }
  function render(state) {
    const playButton = document.getElementById("play-button");
    assert(playButton, "play button not found");
    if (state.gameOver) {
      state.controller.abort();
      playButton.classList.remove("hidden");
      if (getHighScore() < state.score)
        setHighScore(state.score);
    } else
      playButton.classList.add("hidden");
    const title = document.getElementById("title");
    assert(title, "Could not find title");
    title.innerText = state.title;
    for (const col of state.grid)
      for (const row of col) {
        row.element.classList.remove("bg-red-500", "bg-yellow-500");
        switch (row.type) {
          case "empty":
            break;
          case "food":
            row.element.classList.add("bg-red-500");
            break;
          case "snake":
            row.element.classList.add("bg-yellow-500");
            break;
        }
      }
    const score = document.getElementById("score");
    assert(score, "Could not find score");
    score.innerHTML = state.score.toString();
  }
  function printState(state) {
    const copy = JSON.parse(JSON.stringify(state));
    copy.grid.forEach((col) => {
      col.forEach((row) => {
        delete row.element;
      });
    });
    console.log(copy);
  }
  function updatePoint(direction, point) {
    switch (direction) {
      case "down":
        point.row += 1;
        break;
      case "left":
        point.col -= 1;
        break;
      case "right":
        point.col += 1;
        break;
      case "up":
        point.row -= 1;
        break;
    }
  }
  function update(state) {
    state.direction = state.pendingDirection;
    const oldHead = getNode(state.grid, state.head);
    assert(oldHead, "Cannot find old head node");
    assertSnakeNode(oldHead);
    oldHead.direction = state.direction;
    if (state.pause)
      return;
    updatePoint(state.direction, state.head);
    const head = getNode(state.grid, state.head);
    if (head == null || head.type === "snake") {
      state.gameOver = !0;
      state.title = "Game over!";
      return;
    }
    if (head.type === "food") {
      state.score += 1;
      state.food = createFoodPoint(state.grid);
      const foodNode = getNode(state.grid, state.food);
      assert(foodNode, "Cannot find food node");
      foodNode.type = "food";
    } else {
      const tail = getNode(state.grid, state.tail);
      assert(tail, "Could not find tail");
      const snake = tail;
      assertSnakeNode(snake);
      tail.type = "empty";
      updatePoint(snake.direction, state.tail);
    }
    head.type = "snake";
    assertSnakeNode(head);
    head.direction = state.direction;
  }
  async function wait(ms) {
    return new Promise((res) => setTimeout(res, ms));
  }
  async function nextFrame(state, speed) {
    await wait(speed);
    update(state);
    render(state);
  }
  async function run(state) {
    render(state);
    while (!state.controller.signal.aborted)
      await nextFrame(state, getSnakeSpeed(state));
  }
  function main() {
    const root = document.getElementById("root");
    assert(root, "Cannot find root node");
    const grid = initGrid(root), playButton = document.getElementById("play-button");
    assert(playButton, "Cannot find play button");
    playButton.addEventListener("click", () => run(initGameState(grid)));
  }
  main();</script></html>